{
  "version": 3,
  "sources": ["../src/index.ts", "../src/NCCdAPIs.ts"],
  "sourcesContent": ["import { NCCdAPIs } from \"./NCCdAPIs\";\n\nexport const NCCdAPI_DOCS = NCCdAPIs.call('docs', {});\n\n", "// import * as admin from 'firebase-admin';\n// import { validator } from '../../../firebase/functions/src/_shared/tokenValidator';\n\n// export type NCCdApiResponse = {\n// \ttxStatus?: TTMMessage[];\n// \trequestStatus: 'success' | 'fail';\n// \trequestError?: null | string;\n// \trequestErrorMessage?: null | string;\n// \tdata: any;\n// \tmessage: string;\n// \tvalid: boolean;\n// };;\n//\n// To hit the production machine\nconst APIRootURI = 'https://nccdapi.web.app';\n//\n// or to hit Localhost emulator:\n//\n\n// const APIRootURI = 'http://localhost:5001/nccdapi/us-central1/NCCdAPIsV1';\n\n//\n//\n\nfunction sanityCheck(apiEndpoint: string, data: any) {\n\tconsole.log('sanity check');\n\tif (!data.accessToken) {\n\t\tconsole.warn('YOU HAVE NO API KEY!  Just sayin');\n\t}\n\n\tif (!apiEndpoint) {\n\t\tthrow new Error('you must provide an api endpoint!');\n\t}\n}\n\n// // TODO think of another way to validate accessToken for get requests\n// async function validateToken(data: any) {\n// \tconsole.log('HI I AM IN VALIDATE TOKEN');\n\n// \tconst accessToken = data.accessToken;\n\n// \t// we probably don't want to make ourselves manage the expired token response\n// \t// the validator should probably respond directly to expired tokens and halt\n// \tconst tokenIsValid = await validator.validate(db, accessToken);\n// \tif (!tokenIsValid) {\n// \t\tconsole.log('NCCdAPI error: Invalid Token, tourist');\n// \t//   res.status(401).json({ error: 'invalid token' });\n// \t\treturn false;\n// \t}\n\n// \treturn true;\n//   }\n\nexport const NCCdAPIs = {\n\tcall: async function (apiEndpoint: string, data: any, apiVersion?: string) {\n\t\tsanityCheck(apiEndpoint, data);\n\t\tconst version = apiVersion ? apiVersion : 'v1';\n\t\tconsole.log(`running call to ${version}/${apiEndpoint}`);\n\t\tlet jsn = {} as any;\n\t\ttry {\n\t\t\t// in 2022, i feel like we can just go with Fetch.\n\t\t\tconst response = await fetch(`${APIRootURI}/${version}/${apiEndpoint}`, {\n\t\t\t\t// TBD: we can make a map of API calls and their methods and look that up here\n\t\t\t\tmethod: 'POST', // *GET, POST, PUT, DELETE, etc.\n\t\t\t\tcache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached\n\t\t\t\theaders: {\n\t\t\t\t\t'Content-Type': 'application/json'\n\t\t\t\t},\n\t\t\t\tbody: JSON.stringify(data)\n\t\t\t});\n\n\t\t\tjsn = await response.json();\n\t\t\tconsole.log('NCCdAPIs.ts: got response!', jsn);\n\t\t\treturn jsn as any; // NCCdApiResponse;\n\t\t} catch (er: any) {\n\t\t\tconsole.log('there was an error ', er);\n\t\t\treturn {\n\t\t\t\trequestStatus: 'fail',\n\t\t\t\trequestError: er,\n\t\t\t\trequestErrorMessage: er.message\n\t\t\t} as any; // NCCdApiResponse;\n\t\t}\n\t},\n\trequestToken() { },\n\tfetch: async function (apiEndpoint: string, data: any, apiVersion?: string) {\n\t\tsanityCheck(apiEndpoint, data);\n\n\t\t// TODO think of another way to validate accessToken for get requests\n\t\t// const tokenIsValidAndUserCanTransact = await validateToken(data);\n\t\t// if (!tokenIsValidAndUserCanTransact) throw new Error('Invalid token or user cannot transact');\n\n\t\tconst version = apiVersion ? apiVersion : 'v1';\n\t\tconsole.log(`running fetch to ${version}/${apiEndpoint}`);\n\t\tlet jsn = {} as any;\n\t\ttry {\n\t\t\t// in 2022, i feel like we can just go with Fetch.\n\t\t\tconst response = await fetch(`${APIRootURI}/${version}/${apiEndpoint}`, {\n\t\t\t\t// TBD: we can make a map of API calls and their methods and look that up here\n\t\t\t\tmethod: 'GET', // *GET, POST, PUT, DELETE, etc.\n\t\t\t\tcache: 'no-cache' // *default, no-cache, reload, force-cache, only-if-cached\n\t\t\t});\n\n\t\t\tconsole.log('got response!');\n\t\t\tjsn = await response.json();\n\t\t\treturn jsn as any; // NCCdApiResponse;\n\t\t} catch (er: any) {\n\t\t\tconsole.log('there was an error ', er);\n\t\t\treturn {\n\t\t\t\trequestStatus: 'fail',\n\t\t\t\trequestError: er,\n\t\t\t\trequestErrorMessage: er.message\n\t\t\t} as any; // NCCdApiResponse;\n\t\t}\n\t}\n};\n"],
  "mappings": "yaAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,kBAAAE,IAAA,eAAAC,EAAAH,GCcA,IAAMI,EAAa,0BAUnB,SAASC,EAAYC,EAAqBC,EAAW,CAMpD,GALA,QAAQ,IAAI,cAAc,EACrBA,EAAK,aACT,QAAQ,KAAK,kCAAkC,EAG5C,CAACD,EACJ,MAAM,IAAI,MAAM,mCAAmC,CAErD,CAoBO,IAAME,EAAW,CACvB,KAAM,eAAgBF,EAAqBC,EAAWE,EAAqB,CAC1EJ,EAAYC,EAAaC,CAAI,EAC7B,IAAMG,EAAUD,GAA0B,KAC1C,QAAQ,IAAI,mBAAmBC,KAAWJ,GAAa,EACvD,IAAIK,EAAM,CAAC,EACX,GAAI,CAYH,OAAAA,EAAM,MAVW,MAAM,MAAM,GAAGP,KAAcM,KAAWJ,IAAe,CAEvE,OAAQ,OACR,MAAO,WACP,QAAS,CACR,eAAgB,kBACjB,EACA,KAAM,KAAK,UAAUC,CAAI,CAC1B,CAAC,GAEoB,KAAK,EAC1B,QAAQ,IAAI,6BAA8BI,CAAG,EACtCA,CACR,OAASC,EAAP,CACD,eAAQ,IAAI,sBAAuBA,CAAE,EAC9B,CACN,cAAe,OACf,aAAcA,EACd,oBAAqBA,EAAG,OACzB,CACD,CACD,EACA,cAAe,CAAE,EACjB,MAAO,eAAgBN,EAAqBC,EAAWE,EAAqB,CAC3EJ,EAAYC,EAAaC,CAAI,EAM7B,IAAMG,EAAUD,GAA0B,KAC1C,QAAQ,IAAI,oBAAoBC,KAAWJ,GAAa,EACxD,IAAIK,EAAM,CAAC,EACX,GAAI,CAEH,IAAME,EAAW,MAAM,MAAM,GAAGT,KAAcM,KAAWJ,IAAe,CAEvE,OAAQ,MACR,MAAO,UACR,CAAC,EAED,eAAQ,IAAI,eAAe,EAC3BK,EAAM,MAAME,EAAS,KAAK,EACnBF,CACR,OAASC,EAAP,CACD,eAAQ,IAAI,sBAAuBA,CAAE,EAC9B,CACN,cAAe,OACf,aAAcA,EACd,oBAAqBA,EAAG,OACzB,CACD,CACD,CACD,EDhHO,IAAME,EAAeC,EAAS,KAAK,OAAQ,CAAC,CAAC",
  "names": ["src_exports", "__export", "NCCdAPI_DOCS", "__toCommonJS", "APIRootURI", "sanityCheck", "apiEndpoint", "data", "NCCdAPIs", "apiVersion", "version", "jsn", "er", "response", "NCCdAPI_DOCS", "NCCdAPIs"]
}
